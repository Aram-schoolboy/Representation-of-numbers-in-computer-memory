| Лабораторная работа №1 | M3102                  | АОВС |
| ---------------------- |------------------------| ---- |
| Представление чисел    | Мурадян Арам Суренович | 2024 |


## Инструментарий
> C++ 17

## Вариант
> Normal

## Результат работы на тестовых данных: https://github.com/skkv-itmo-comp-arch/se-comp-arch24-fixed-floating-Aram-schoolboy/actions/runs/8101310804

# Описание:

## Fixed point

### Class PrintingNumber
>- Принимает на вход A, B, битовое представление числа  
>- В классе реализовано 5 функций  
>- Print() - выводит число  
>- 4 функции, округляющих число  
>- FirstFourDigits - вспомогательная структура для работы с дробной частью в 10-ой СС


Реализуем класс PrintingNumber, в котором реализована основная функция Print(RoundingType) - функция вывода 32-битного числа в дополнительном коде в формате A.B в десятичной СС с 3 знаками после точки с заданным округлением.


### FirstFourDigits
>- Хранит в себе 4 числа - разряд 1/10, 1/100, 1/1000, 1/10000  
>- Умеет инкрементировать себя и сообщать о переполнении

### Print
Достанем из исходного представления целую (за нее отвечают биты с B+1-ого по A+B-ый, где A+B-ый бит идет со знаком минус, т.к. число представлено в доп. коде) и дробную части (за нее отвечают биты с 1-ого по B-ый, если B != 0). Если число отрицательное и дробная часть != 0, то прибавим к целой части единицу, т.к. дробная часть идет как положительная, и сделаем ее “отрицательной” (вычитая из единицы дробную исходную часть). Чтобы получить первые 4 числа (4-ое необходимо для определения округления к ближайшему четному) после точки, умножим дробную часть на 10 в 4-ой степени и поделим на 2 в степени B, т.к. наша дробная часть до этого была домножена на 2 в степени B.
Заведем для удобного хранения и работы с четырьмя первыми цифрами после запятой структуру FirstFourDigits, которая на вход получает число, полученное на предыдущем шаге, и, используя деление и взятие по модулю распаршивает его:
поле структуры bool overflow отвечает за переполнение дробной части, что происходит в случае “999” и инкремента (получается “000” и на единицу необходимо увеличить целую часть). После получения дробной и целой части в почти конечном виде, необходимо это всё округлить, используя одну из ниже определенных функций. Затем вывести результат.
Заметим, что после округления знак числа мог поменяться. Например, если было маленькое отрицательное число, то после округления оно могло стать -0.000, а это некорректный вывод для фиксированной точки, поэтому этот случай надо "заифать".

### RoundTowardZero
Ничего не делает, т.к. необходимо просто проигнорировать все числа после разряда тысячных, т.е. вывести целую часть и первые три числа после точки.

### RoundTowardInfinity
Если число отрицательное, то ничего не делает (т.к. необходимо проигнорировать младшие разряды, ведь они лишь увеличивают модуль нашего отрицательного числа, что “отдаляет” его от +бесконечности). Если число положительное, то необходимо проверить, есть ли разряды после тысячных и, если да, то увеличить модуль числа на 0.001. Заметим, что если в бинарной форме дробной части нет единичек, отвечающих за 1/16, 1/32 и т.д., то в десятичной форме просто неоткуда взяться ненулевым числам на разрядах младше тысячных.
Иначе обязательно найдется в десятичном представлении число разряда младше тысячных. Итак, если нашелся бит на позиции дальше 3-ьей, то увеличим дробную часть и, если она переполнилась, то увеличим на единицу целую часть (мы работаем с положительными числами, т.к. отрицательные отсеялись в самом начале).

### RoundTowardNegInfinity
Аналогично округлению к +бесконечности. Только при обнулении дробной части после ее инкремента (увеличения разряда тысячных на единичку) необходимо уменьшить целую часть на единичку, а не увеличить, т.к. здесь числа отрицательные.

### RoundToNearestEven
Если 4-ая цифра меньше 5,то ничего не делает, если больше, то делает инкремент. Если равна 5, то смотрит, есть ли дальше какие-то цифры (по аналогии с округлением к бесконечностям). Если да, то делает инкремент. Если нет, то смотрит на четность третьей цифры и в зависимости от этого делает инкремент. В случае перехода дробной части из 999 в 000 увеличивает\уменьшает дробную часть в зависимости от знака.


### BinaryRoundings
Это вспомогательная структура в которой определены функции 4 видов округления. Функция принимает на вход B битов дробной части как uint32_t, булеву переменную, которая отвечает за то, есть ли на самом деле после B+1-ого бита еще ненулевые биты и булеву переменную, которая является B+1-ым битом.
Этой информации достаточно, чтобы произвести округление. Здесь всё происходит аналогично округлениям в десятичной системе, за исключением других "циферок". B+1-ый бит передается только ради того, чтобы суметь сделать округление к ближайшему четному, т.к. оно зависит конкретно от его значения.  


### Operation +
Младшие биты не теряются, значит округление делать не надо. Необходимо сделать лишь отбросить возможные старшие биты. Для этого напишем функцию ModularArithmetic(), которая будет обнулять старшие k битов. Чтоб сделать саму операцию непосредственно, просто сложим числа в таком виде, в котором они даны (тип - uint32_t). Числа в доп. коде можно спокойно складывать. При сложении двух больших чисел может произойти переполнения типа uint32_t, однако старший 33-ий бит просто напросто сам обрежется и никаких проблем не возникнет. Ведь мы бы так и так отрезали его сами чуть позже (по условию A + B <= 32, а выводить числа надо в таком же формате A.B)

### Operation -
Операция вычитания - x - y = x + (-y). Поэтому давайте сведем вычитание к сложению. Надо только получить из числа y число -y. Это можно сделать как инвертирование битов + 1, например.

### Operation *
Операция умножения - запомним знаки чисел, возьмем модули чисел и перемножим их. Получили B*2 битов дробной части. Отдельно рассмотрим случай, когда B = 0. Тогда необходимо сделать только модулярную арифметику и передать результат в PrintingNumber, чтобы вывести число. 
Иначе давайте запомним, есть ли ненуевые биты после B+1 - ого бита, сдвинем полученное произведение вправо на B-1 бит. Таким образом имеем B+1 битов дробной части, информацию о том, есть ли далее ненулевые биты, а так же целую часть. 
То есть имеем всю информацию, чтобы произвести округление. Воспользуемся для этого функциями структуры BinaryRoundings. В случае переполнения дробной части увеличим модуль целой части. Далее, учитывая знак, переведем полученный результат обратно в формат дополнительного кода, сделаем модулярную арифметику и передадим результат в PrintingNumber.

### Operation /
Запомним знаки делимого и делителя и далее все будем делать без знака, вспомним про него только в конце. 
Делимое домножим на 2 в степени B + 1, чтобы получить B+1 знак после запятой. поделим числа и запишем результат в переменную T.
Первые B+1 битов - дробная часть результирующего числа, а остальные - целая часть числа. Если T * делитель = делимое, то мы никакие биты не потеряли, т.е. все биты дробной части, не считая B+1 битов, которые мы знаем - нулевые. 
Иначе есть ненулевые биты меньших разрядов. T * делитель <= делимое.  (Все переменные вмещаются в uint64_t, т.к. делимое, домноженное на 2 в степени B + 1 максимум будет занимать 32 + 31 + 1 = 64 бита. 
T < делимое. T * делитель <= делимое.) Запустим бинарное округление. В случае переполнения дробной части увеличим модуль целой части. Далее, учитывая знак, переведем полученный результат обратно в формат дополнительного кода, сделаем модулярную арифметику и передадим результат в PrintingNumber.

## Floating point
> Конструктор класса получает на вход формат числа - h\f, представление числа в данном формате и тип округления  
> Разбивает полученное число на знак, экспоненту и мантиссу. Если число денормализованное, то считает "настоящую" экспоненту числа и сдвигает мантису на столько, что первая единичка становится "фантомной"
>, как у нормальных чисел.
> Перед тем, как разбить число на составляющие, запускается функция SetNumberType, которая проверяет,
> не является ли число наном, +-бесконечностью, +-нулем. В таком случае в дальнейшем все операции для этих объектов определены с помощью "ифов".
### Print
Если число является объектом одного из этих типов: (+- бесконечность, +- 0 или нан), то выводим соответствующее значение, как задано в условии.  
Иначе выводим -0х1. , затем мантиссу, сдвинутую на 2 влево для h и на 1 для f формата, с помощью printf. Затем p, знак экспоненты и саму экспоненту (настоящую, т.к. по дефолту она хранится со сдвигом 127\15)
  

*Перед каждой арифметической операцией отдельно рассматриваются все случаи с объектами +-0, +-бесконечность, нанами, х - х, поэтому в самих функциях далее работа идет либо с нормальными числами, либо денормализованными, причем ненулевыми.

### Overflow()
В зависимости от знака вовзвращает максимальное по модулю число заданного знака или бесконечность заданного знака.
Если округление к нулю, то максимальное по модулю число, если к ближайшему четному, то бесконечность. Если округление к + бесконечности и число отрицательное, то максимальное по модлую отрицательное и наоборот, если округление к - бесконечности.

### Underflow()
В зависимости от знака возвращаем минимальное денормализованное по модулю число заданного знака или 0 заданного знака.
Если округление к нулю, то ноль, если к ближайшему четному, то смотрим на экспоненту. Если она меньше -150\-25 или мантиса числа ненулевая, то возврвщаем ноль.
Иначе минимальное число. Если округление к + бесконечности, а число отрицательное, то ноль (с минусом), в случае округления к -бесконечности - наоборот.


### RoundMantis()
Находит лидирующую единицу. От нее справа находит мантису. Еще правее биты считает использует для округления. Здесь округление проходит как и в обычном бинарном округлении. Если мантиса переполнилась после инкремента, то функция записывает в переменную overflow = true. Возвращает округленную мантиссу.

### RoundDenormalMantis()
То же, что и RoundMantis(). Только учитывает тот факт, что число денормализованное и начало мантисы считает с учетом экспоненты.

### Operation +
Найдем большее число и меньшее число (big, small), сравнивая экспоненты и в случае их равенства мантисы чисел. Рассмотрим дельту экспонент. Если она не очень велика, то сдвинув оба числа влева и вычитая из первого второго
мы не потеряем точность. После чего сумеем сделать округление и вернуть результат. Иначе заметим, что числа отличаются очень сильно, и число большего порядка просто напросто либо поглотит меньшее число, либо получится следующее возможное представимое число (чуть больше или чуть меньше). В таком случае просто посмотрим на то, какой тип округления и сделаем нужные действия.

### Operation -
То же, что и сложение, просто поменяем знак у второго слагаемого

### Operation *
Запоминаем результирующий знак. Новая экспонента - сумма экспонент множителей. Перемножаем мантисы в новую
переменную формата uint64_t, причем в мантисы добавляем лидирующие единицы. Это справедливо и для денормализованных чисел тоже,
потому что на этапе конструктора денормализованные числа мы нормализовали. В случае если лидириующая единица в результирующей мантисе сменила свой индекс (он отличается от индекса лидирующей
единицы, которая стоит в мантисе у одного из множеителей (с учетом "фантомной" единицы)), то экспоненту необходимо увеличить на единицу. Далее проверяем на оверфлоу, т.к. экспонента увеличилась. Если действительно экспонента стала
слишком большой, то запускаем фукнцию Overflow(). Если мантиса после округления переполнилась, увеличиваем экспоненту. Если после увеличения число стало слишком большим, запускаем функцию оверфлоу и возвращаем ее результат. Иначе Теперь у нас есть мантиса, экспонента и знак. Строим новое число и выводим.

### Operation /
Во многом похоже на умножение. Запоминаем результирующий знак. Новая экспонента - разность экспонент множителей. Делим мантисы в новую
переменную формата uint64_t, причем в мантисы добавляем лидирующие единицы а также делимую мантисы сдвигаем на 1 влево, чтобы не получить просто 0, если она меньше.
Округляем новую мантису, учитывая все то же, что и в уумножении и возвращаем результат.
